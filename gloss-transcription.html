<!DOCTYPE html>
<html lang="en">

<head>
    <title>Gallery of Glosses</title>
    <link rel="stylesheet" href="css/gloss.css">
    <link href="favicon.ico" rel="icon" type="image/x-icon" />
    <script src="js/auth.js" type="module"></script>
    <script src="js/deer.js" type="module"></script>
    <script src="js/layout.js" type="module"></script>
    <script src="js/lineSelector.js" type="module"></script>
    <script src="js/glossModal.js" type="module"></script>
    <script src="js/shared.js"></script>
    <style>
       .toggle{
            position: absolute;
            cursor: pointer;
            top: 0;
            right: 0;
            font-weight: bold;
       }
       .toggle::before{
            content: "toggle all text ";
            font-family: "Eczar","Volkhov",serif;
            font-size: 8pt;
       }
       .tpenProjectLines.is-toggled, .pageContainer.is-toggled{
            visibility: hidden;
            height: 0px;
       }
       input.required{
            border: 1px solid black;
       }
    </style>
</head>

<body class="container">
    <gog-header class="container"></gog-header>
    <h2 class="bg-basic"> Named Gloss Transcription Witness </h2>
    <p class="bg-basic"> Connect Named Glosses with text in T-PEN Transcriptions. </p>
    <div id="needs" class="row bg-basic">
        <p class="howTo"> 
            It looks like you haven't provided a TPEN Manifest URI.  If you are not using the <code>?tpen-project=</code> URL parameter, you can supply a URI here.  
            <input id="resourceURI" type="text" placeholder="TPEN Manifest URI"/>
            <input id="loadInput" type="button" onclick="loadURI(event)" value="Load TPEN Manifest" />
        </p>
    </div>
    <!-- Since the pieces require each other, only show the interface when all components have loaded enough -->
    <!-- Our limiter here is the Named Glosses Collection.  We need to wait on the paged query. -->
    <div id="loading" class="tpen-needed is-hidden">
        <p style="color: white;"> 
            Please be patient while we get things together...  
        </p>
    </div>
    <form id="witnessForm" class="is-hidden" deer-type="Text" deer-context="http://purl.org/dc/terms"> 
        <input is="auth-creator" type="hidden" deer-key="creator" />
        <input type="hidden" custom-key="source">
        <div class="row">
            <label class="col-3 col-2-md text-right is-hidden">Label:</label>
            <input type="text" deer-key="label" placeholder="Label" class="col-9 col-10-md is-hidden">

            <label class="col-3 col-2-md text-right">Shelfmark &#10082;</label>
            <input type="text" deer-key="identifier" placeholder="A Shelfmark is required" class="col-9 col-10-md required" required>
                        
            <!--             
                <label class="col-3 col-2-md text-right">Depictions:</label>
                <input type="number" deer-key-todo="depiction" placeholder="" class="col-9 col-4-md"> 
            -->

            <label class="col-3 col-2-md text-right" >Text:</label>
            <textarea custom-text-key="text" rows="2" class="col-9 col-10-md" placeholder="Highlight transcription text..."></textarea>

            <label class="col-3 col-2-md text-right">Language:</label>
            <select custom-text-key="language" title="select language" class="col-9 col-4-md">
                <option value="la" selected>Latin</option>
                <option value="de">German</option>
                <option value="fr">French</option>
                <option value="en">English</option>
            </select>

            <label title="Select the checkbox if the text contains markup tags like HTML or XML" class="col-12 col-6-md text-left">
                The text contains <code>&lt; tags &gt;</code><input type="checkbox" custom-text-key="format" value="text/plain" />
            </label>

            <!-- Useful but not used yet.  It is never shown in the UI and stays 'is-hidden' -->
            <label class="col-3 col-2-md text-right is-hidden" placeholder="Chosen Named Gloss Incipit">Chosen Named Gloss</label>
            <textarea disabled title="Choose a Named Gloss to see the incipit here" placeholder="Choose a Named Gloss below..." class="chosenNamedGloss col-9 col-10-md is-hidden"></textarea>
        </div>
        <input class="is-hidden" type="submit" value="Create Textual Witness"/>
        <div class="row">
            <tpen-line-selector class="lineSelector tpen-needed is-hidden col-7-md col-6-sm"> </tpen-line-selector>
            <deer-view class="tpen-needed is-hidden col-5-md col-6-sm" id="ngCollectionList" deer-listing deer-collection="Glossing-Matthew-Named-Glosses" deer-link="ng.html#" deer-template="glossesSelectorForTextualWitness">
            Loading&hellip;
            </deer-view>  
        </div>
    </form>
    <gog-footer class="row"></gog-footer>
    <div id="globalFeedback" class="card is-center"></div>
    <gloss-modal class="is-hidden"></gloss-modal>
    <script>

        /**
         * Reset all the form elements so the form is ready to generate a new witness.
         * This occurs after the user submits a new witness.
         * If they provided a witness and are updating it, do not perform the reset.
         */ 
        function setFormDefaults(){
            const form = document.querySelector("form")
            const textWitnessID = window.location.hash.substr(1)

            // Continue the session like normal if they had loaded up an existing witness and updated it.
            if(textWitnessID) return
                
            form.removeAttribute("deer-id")
            form.removeAttribute("deer-source")    
            form.$isDirty = true
            
            const labelElem = form.querySelector("input[deer-key='label']")
            labelElem.value = ""
            labelElem.setAttribute("value", "")
            labelElem.removeAttribute("deer-source")
            labelElem.$isDirty = false

            const shelfmarkElem = form.querySelector("input[deer-key='identifier']")
            shelfmarkElem.value = ""
            shelfmarkElem.setAttribute("value", "")
            shelfmarkElem.removeAttribute("deer-source")
            shelfmarkElem.$isDirty = false

            const formatElem = form.querySelector("input[custom-text-key='format']")
            formatElem.removeAttribute("deer-source")
            formatElem.$isDirty = true

            const textElem = form.querySelector("textarea[custom-text-key='text']")
            textElem.value = ""
            textElem.setAttribute("value", "")
            textElem.removeAttribute("deer-source")
            textElem.$isDirty = false

            const languageElem = form.querySelector("select[custom-text-key='language']")
            languageElem.removeAttribute("deer-source")
            languageElem.$isDirty = true

            const selectionsElem = form.querySelector("input[custom-key='selections']")
            selectionsElem.value = ""
            selectionsElem.setAttribute("value", "")
            selectionsElem.removeAttribute("deer-source")
            selectionsElem.$isDirty = false

            const referencesElem = form.querySelector("input[custom-key='references']")
            referencesElem.value = ""
            referencesElem.setAttribute("value", "")
            referencesElem.removeAttribute("deer-source")
            referencesElem.$isDirty = false

            // reset the named glosses filter
            const filter = form.querySelector('input[filter]')
            filter.value = ""
            filter.setAttribute("value", "")
            filter.dispatchEvent(new Event('input', { bubbles: true }))

            //remove text selection
            let sel = window.getSelection ? window.getSelection() : document.selection
            if (sel) {
                if (sel.removeAllRanges) {
                    sel.removeAllRanges()
                } else if (sel.empty) {
                    sel.empty()
                }
            }
        }

        /**
         * Attach all the vent handlers to the custom key areas.
         * Prepare the UI/UX for either 'create' or 'update' scenarios depending on the url hash.
         * Set fixed value fields and make those inputs dirty.
         */ 
        window.onload = () => {
            setPublicCollections()
            setListings()
            const tpenID = getURLParameter("tpen-project")
            const dig_location = document.querySelector("input[custom-key='source']")
            if(tpenID) {
                needs.classList.add("is-hidden")
                document.querySelectorAll(".tpen-needed").forEach(el => el.classList.remove("is-hidden"))
                document.querySelector(".lineSelector").setAttribute("tpen-project", tpenID)
                dig_location.value = tpenID
                dig_location.setAttribute("value", tpenID)
            }
            const textWitnessID = window.location.hash.substr(1)
            if(textWitnessID){
                const submitBtn = document.querySelector("input[type='submit']")
                submitBtn.value = "Update Textual Witness"
                submitBtn.classList.remove("is-hidden")
                document.querySelector("form").setAttribute("deer-id", textWitnessID)
            }
            else{
                // These items have default values that are dirty on fresh forms.
                dig_location.$isDirty = true
                document.querySelector("select[custom-text-key='language']").$isDirty = true
                document.querySelector("input[custom-text-key='format']").$isDirty = true
                // remove this to support the specialized form reset
                removeEventListener("deer-form-rendered", init)
            }

            // mimic isDirty detection for these custom inputs
            document.querySelector("select[custom-text-key='language']").addEventListener("change", ev => {
                ev.target.$isDirty = true
                ev.target.closest("form").$isDirty = true
            })
            document.querySelector("textarea[custom-text-key='text']").addEventListener("input", ev => {
                ev.target.$isDirty = true
                ev.target.closest("form").$isDirty = true
            })
            // Note that this HTML element is a checkbox
            document.querySelector("input[custom-text-key='format']").addEventListener("click", ev => {
                if(ev.target.checked){
                    ev.target.value = "text/html"
                    ev.target.setAttribute("value", "text/html")
                }
                else{
                    ev.target.value = "text/plain"
                    ev.target.setAttribute("value", "text/plain")
                }
                ev.target.$isDirty = true
                ev.target.closest("form").$isDirty = true
            })
            setTimeout(() => {
                document.querySelectorAll("input[deer-key='creator']").forEach(el => {
                    el.value="HabesTest"
                    el.setAttribute("value", "HabesTest")
                })
                witnessForm.setAttribute("deer-creator", "HabesTest")
                document.getElementById("named-gloss-modal").setAttribute("deer-creator", "HabesTest")
                window.GOG_USER["http://store.rerum.io/agent"] = "HabesTest"
            }, 4000)
        }

        /**
         * When the Named Gloss Collection List deer view loads its records we can show the witness form.
         * Note the Collection List may still need to fully populate and cache, but it has a UI/UX for that.
         */ 
        addEventListener('deer-view-rendered', event => {
            if(event.target.id == "ngCollectionList"){
                loading.classList.add("is-hidden")
                witnessForm.classList.remove("is-hidden")
            }
        })

        /**
         * Paginate the custom data fields in this witness form.
         * Note that it is only fired when the page recieve a witness URI in the url hash.
         */ 
        function init(event){
            let whatRecordForm = event.target.id
            let annotationData = event.detail
            const $elem = event.target
            switch (whatRecordForm) {
                case "witnessForm":
                    if(ngCollectionList.hasAttribute("ng-list-loaded")){
                        prefillReferences(annotationData["references"], ngCollectionList)
                    }
                    else{
                        addEventListener('deer-view-rendered', ev => {
                            if(ev.target.id === "ngCollectionList"){
                                prefillReferences(annotationData["references"], ngCollectionList)
                            }
                        })
                    }
                    if(document.querySelector("tpen-line-selector").hasAttribute("tpen-lines-loaded")){
                        preselectLines(annotationData["selections"], $elem)    
                    }
                    else{
                        addEventListener('tpen-lines-loaded', ev => {
                            preselectLines(annotationData["selections"], $elem)
                        })
                    }
                    prefillText(annotationData["text"], $elem)
                    prefillDigitalLocations(annotationData["source"], $elem)
                    break
                default:
            }
        }

        /**
         * Detects that all annotation data is gathered and all HTML of the form is in the DOM and can be interacted with.
         * Note that it is only required when a witness URI was provided by the url hash.
         * This is important for pre-filling or pre-selecting values of multi select areas, dropdown, checkboxes, etc. 
         * This event will come after all deer-view-rendered events have finished.
         * @see deer-record.js DeerReport.constructor()  
         */
        addEventListener('deer-form-rendered', init)

        /**
         * Helper function for the specialized text key, which is an Object.
         * Note that format is hard coded to text/plain for now.
         * */
        function prefillText(textObj, form) {
            const languageElem = form.querySelector("select[custom-text-key='language'")
            const formatElem = form.querySelector("input[custom-text-key='format'")
            const textElem = form.querySelector("textarea[custom-text-key='text'")
            if (textObj === undefined) {
                console.warn("Cannot set value for text and build UI.  There is no data.")
                return false
            }
            if(![languageElem,formatElem,textElem].some(e=>e)) {
                console.warn("Nothing to fill.")
                return false
            }
            const source = textObj?.source
            if(source?.citationSource){
                form.querySelector("select[custom-text-key='language'")?.setAttribute("deer-source", source.citationSource ?? "") 
                form.querySelector("input[custom-text-key='format'")?.setAttribute("deer-source", source.citationSource ?? "") 
                form.querySelector("textarea[custom-text-key='text'")?.setAttribute("deer-source", source.citationSource ?? "") 
            }
            textObj = textObj.value ?? textObj
            const language = textObj.language
            if(languageElem) {
                languageElem.value = language
                languageElem.setAttribute("value", language)
            }
            
            const format = textObj.format
            if(format === "text/html"){
                formatElem.checked = true
            }
            if(formatElem) {
                formatElem.value = format
                formatElem.setAttribute("value", "format")
            }
            const textVal = textObj.textValue
            if (!textVal) {
                console.warn("There is no text recorded for this witness")
                return false
            }
            if(textElem){
                textElem.value = textVal
                textElem.setAttribute("value", textVal)
            }
        }

         /**
         * Helper function for the specialized references key, which is an Array of URIs.
         * It needs to apply the filter with this Named Gloss's Label..
         * */
        function prefillDigitalLocations(locationsArr, form) {
            const locationElem = form.querySelector("input[custom-key='source']")
            if(!locationElem) {
                console.warn("Nothing to fill")
                return false
            }
            if (locationsArr === undefined) {
                console.warn("Cannot set value for digital locations and build UI.  There is no data.")
                return false
            }
            if (!locationsArr.length) {
                console.warn("There are no digital locations recorded for this witness")
                return false
            }
            const source = locationsArr?.source
            if(source?.citationSource){
                form.querySelector("input[custom-key='source']").setAttribute("deer-source", source.citationSource ?? "")
            }
            locationsArr = locationsArr?.value ?? locationsArr
            locationElem.value = locationsArr[0]
        }

        /**
         * Helper function for the specialized references key, which is an Array of URIs.
         * It needs to apply the filter with this Named Gloss's Label..
         * */
        function prefillReferences(referencesArr, form) {
            if (referencesArr === undefined) {
                console.warn("Cannot set value for references and build UI.  There is no data.")
                return false
            }            

            
            const source = referencesArr?.source
            referencesArr = referencesArr?.value ?? referencesArr
            if (referencesArr.length === 0) {
                console.warn("There are no references recorded for this witness")
                return false
            }

            const ngID = referencesArr[0]

            const elem = form.querySelector(`li[deer-id="${ngID}"]`)
            const ngLabel = elem.getAttribute("data-title")
            const filter = document.querySelector("input[filter]")
            const refElem = form.querySelector("input[custom-key='references']")
            if(![elem,ngLabel,filter,refElem].some(e=>e)) {
                console.warn("Nothing to fill.")
                return false
            }

            if(source?.citationSource){
                refElem.setAttribute("deer-source", source.citationSource ?? "")
            }
            refElem.value = referencesArr[0]
            
            // Now apply the references value to the filter
            const button = elem.querySelector(".toggleInclusion")
            button?.setAttribute("disabled", "")
            button?.setAttribute("value", "✓ attached")
            button?.setAttribute("title", "This Named Gloss is already attached!")
            button?.classList.remove("primary")
            button?.classList.add("success")
            filter.value = ngLabel.trim()
            filter.dispatchEvent(new Event('input', { bubbles: true }))
            const chosenGloss = document.querySelector(".chosenNamedGloss")
            if(chosenGloss) chosenGloss.value = ngLabel
        }

        /**
         * Helper function for the specialized references key, which is an Array of URIs.
         * It needs to apply the filter with this Named Gloss's Label.
         * */
        function preselectLines(linesArr, form) {
            const source = linesArr.source ?? null
            if (linesArr === undefined) {
                console.warn("Cannot highlight lines in UI.  There is no data.")
                return false
            }
            linesArr = linesArr.value ?? linesArr
            if (linesArr.length === 0) {
                console.warn("There are no lines recorded for this witness")
                return false
            }
            const selectionsElem = form.querySelector("input[custom-key='selections']")
            if(source?.citationSource){
                selectionsElem.setAttribute("deer-source", source.citationSource ?? "")
            }
            selectionsElem.value = linesArr.join("__")

            //Now highlight the lines
            let range = document.createRange()
            let sel = window.getSelection()
            let line = linesArr[0]
            let lineid = line.split("#")[0]
            const lineStartElem = document.querySelector(`div[tpen-line-id="${lineid}"]`)
            lineStartElem.parentElement.previousElementSibling.classList.add("has-selection")
            let selection = line.split("#")[1].replace("char=", "").split(",")           
            range.setStart(lineStartElem.firstChild, parseInt(selection[0]))
            if(linesArr.length > 1){
                line = linesArr.pop()
                lineid = line.split("#")[0]
                const lineEndElem = document.querySelector(`div[tpen-line-id="${lineid}"]`)
                lineEndElem.parentElement.previousElementSibling.classList.add("has-selection")
                selection = line.split("#")[1].replace("char=", "").split(",")           
                range.setEnd(lineEndElem.firstChild, parseInt(selection[1]))
            }
            else{
                range.setEnd(lineStartElem.firstChild, parseInt(selection[1]))
            }
            sel.removeAllRanges()
            sel.addRange(range)
            document.querySelectorAll(".togglePage:not(.has-selection)").forEach(tog => {
                if(!tog.classList.contains("is-toggled")){
                    tog.click()
                }
            })  
        }

        function loadURI(){
            let url = resourceURI.value ? resourceURI.value : getURLParameter("tpen-project")
            if(url){
                let tpen = "?tpen-project="+url
                url = window.location.href.split('?')[0] + tpen
                window.location = url
            }
            else{
                alert("You must supply a URI via the IIIF Content State iiif-content parameter or supply a value in the text input.")
            }
        }

        addEventListener('deer-updated', event => {
            const $elem = event.target
            //Only care about witness form
            if($elem?.id  !== "witnessForm") return
            const entityID = event.detail["@id"]  
            // These promise are for all the simple array values ('references' and 'selections')
            let annotation_promises = Array.from($elem.querySelectorAll("input[custom-key]"))
                .filter(el => el.$isDirty)
                .map(el => {
                    const key = el.getAttribute("custom-key")
                    let anno = {
                        "@context": "http://www.w3.org/ns/anno.jsonld",
                        "@type": "Annotation",
                        "body": {},
                        "target": entityID,
                        "creator" : window.GOG_USER["http://store.rerum.io/agent"]
                    }
                    anno.body[key] = { "value": el.value.split("__") }
                    if(el.hasAttribute("deer-source")) anno["@id"] = el.getAttribute("deer-source")
                    return fetch(`${__constants.tiny}/${el.hasAttribute("deer-source")?"update":"create"}`, {
                        method: `${el.hasAttribute("deer-source")?"PUT":"POST"}`,
                        mode: "cors",
                        headers: {
                            "Content-Type": "application/json; charset=utf-8",
                            "Authorization": `Bearer ${window.GOG_USER.authorization}`
                        },
                        body: JSON.stringify(anno)
                    })
                    .then(res => res.json())
                    .then(a => {
                        el.setAttribute("deer-source", a["@id"])
                    })
                    .catch(err => {
                        console.error(`Could not generate Annotation for key '${key}'`)
                        console.error(err)
                    })
                })

            // This gets the custom keys for the annotation.body.text which is an object
            // If any of the elements that build the object are dirty, then it is dirty.
            const customTextElems = [
                $elem.querySelector("input[custom-text-key='format']"),
                $elem.querySelector("select[custom-text-key='language']"),
                $elem.querySelector("textarea[custom-text-key='text']")
            ]
            if(customTextElems.filter(el => el.$isDirty).length > 0){
                // One of the text properties has changed so we need the text object
                const format = customTextElems[0].value
                const language = customTextElems[1].value
                const text = customTextElems[2].value
                let textanno = {
                    "@context": "http://www.w3.org/ns/anno.jsonld",
                    "@type": "Annotation",
                    "body": {
                        "text":{
                            "format" : format,
                            "language" : language,
                            "textValue" : text
                        }
                    },
                    "target": entityID,
                    "creator" : window.GOG_USER["http://store.rerum.io/agent"]
                }
                const el = customTextElems[2]
                if(el.hasAttribute("deer-source")) textanno["@id"] = el.getAttribute("deer-source")
                annotation_promises.push(
                    fetch(`${__constants.tiny}/${el.hasAttribute("deer-source")?"update":"create"}`, {
                        method: `${el.hasAttribute("deer-source")?"PUT":"POST"}`,
                        mode: 'cors',
                        headers: {
                            "Content-Type": "application/json; charset=utf-8",
                            "Authorization": `Bearer ${window.GOG_USER.authorization}`
                        },
                        body: JSON.stringify(textanno)
                    })
                    .then(res => res.json())
                    .then(a => {
                        $elem.setAttribute("deer-source", a["@id"])
                    })
                    .catch(err => {
                        console.error(`Could not generate 'text' property Annotation`)
                        console.error(err)
                    })
                )
            }
            Promise.all(annotation_promises)
            .then(success => {
                console.log("Successfully connected custom key Annotations")
                const ev = new CustomEvent("Named Gloss Textual Witness Submitted")
                globalFeedbackBlip(ev, `Named Gloss Textual Witness Submitted!`, true)
                const textWitnessID = window.location.hash.substr(1)
                // If we are updating a witness keep the interface.  If we just sumbitted a new one, refresh the form to be ready for another new one.
                if(!textWitnessID) setFormDefaults()  
            })
            .catch(err => {
                console.error("Did not connect all custom key Annotations!!")
                console.error(err)
            })
        })

        /**
         * Detects that the modal saved a new Gloss and contains that new Gloss's details.
         */
        addEventListener('gloss-modal-saved', event => {
            if(event.target.tagName !== "GLOSS-MODAL") return
            const gloss = event.detail
            const form = witnessForm
            const view = form.querySelector("deer-view[deer-template='glossesSelectorForTextualWitness']")
            const list = view.querySelector("ul")
            const modal = event.target
            const title = modal.querySelector("form").querySelector("input[deer-key='title']").value
            modal.classList.add("is-hidden")
            const inclusionBtn = document.createElement("input")
            inclusionBtn.setAttribute("type", "button")
            inclusionBtn.setAttribute("href", gloss["@id"])
            inclusionBtn.setAttribute("title", "Attach this Named Gloss and Save")
            inclusionBtn.setAttribute("value", "➥ attach")
            inclusionBtn.setAttribute("class", "toggleInclusion button primary")
            inclusionBtn.setAttribute("data-title", title)
            inclusionBtn.addEventListener('click', ev => {
                ev.preventDefault()
                ev.stopPropagation()
                const namedGlossIncipit = ev.target.getAttribute("data-title")
                const customKey = form.querySelector("input[custom-key]")
                const filter = form.querySelector('input[filter]')
                filter.value = namedGlossIncipit
                filter.setAttribute("value", namedGlossIncipit)
                filter.dispatchEvent(new Event('input', { bubbles: true }))
                const uri = a.getAttribute("href")
                if(customKey.value !== uri){
                    customKey.value = uri 
                    customKey.setAttribute("value", uri) 
                    customKey.$isDirty = true
                    form.$isDirty = true
                    // There must be a shelfmark.
                    if(form.querySelector("input[deer-key='identifier']").value){
                        form.querySelector("input[type='submit']").click()    
                    }
                    else{
                        alert("You must provide a Shelfmark value.")
                    }
                }
                else{
                    alert(`This textual witness is already attached to Named Gloss '${namedGlossIncipit}'`)
                }
            })
            const li = document.createElement("li")
            const a = document.createElement("a")
            const span = document.createElement("span")

            // This Gloss was just created and is not cached.
            // Make this a deer-view so this Gloss is expanded and we can make attributes from its properties.
            li.classList.add("deer-view")
            li.setAttribute("deer-template", "filterableListItem")
            li.setAttribute("deer-id", gloss["@id"])
            li.setAttribute("data-title", title)
            li.setAttribute("deer-template", "filterableListItem")
            li.setAttribute("deer-link", "ng.html#")

            a.setAttribute("target", "_blank")
            a.setAttribute("href", `ng.html#${gloss["@id"]}`)

            span.innerText = title

            a.appendChild(span)
            li.appendChild(inclusionBtn)
            li.appendChild(a)
            list.appendChild(li)

            // FIXME this doesn't seem to make this li element expand() and get the properties.
            // This means it is not cached and does not appear on page refresh.  You have to clear and re-initialize the cache to see it.
            // WE NEED THIS or else we need to expand the entity here and add it to cache.
            broadcast(undefined, "deer-view", li, { set: [li] })

            inclusionBtn.click()
        })
    </script>
</body>

</html>
